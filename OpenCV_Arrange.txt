1.tutorial_RW
  numpy 是一个科学计算的一个包 用于计算n维数组的对象
  matplotlib.plt 是一个画图软件

  # 图像信息获得
  def get_image_info(image):
    print("图像类型：",type(image))
    print("图像高x宽x通道数：",image.shape) #这是一个数组 0,1,2 分别表示对应的数字
    print("图像长宽通道数相乘所得值：",image.size)
    print("图像像素值类型：",image.dtype) 如int32等
    pixel_data = np.array(image)  # 将图片转换成数组
    print("像素大小：", pixel_data)

  # 图片信息保存
  def save_image(image):
    gray = cv.cvtColor(src, cv.COLOR_BGR2GRAY)  # 将src图片转换成灰度图
    cv.imwrite("output.png", gray)  # 将转化后的灰度图写入到GrayCrystal.png中，可以用来转换图片格式

  # 获取视频
  def video_demo():
  首先定义一个video_demo函数 
	调用capture = cv.VideoCapture()方法 里面的参数莫认为0 表示指定的摄像头
	定义一个while循环
	调用read方法返回的是结果容器 ret,frame = capture.read() 返回ret结果(True/Flase)以及每一帧
        用flip方法,frame = cv.flip(frame,1) 方法将frame进行赋值 1表示水平翻转 0表示竖直翻转
	cv.imshow("video",frame)表示 将每一帧图片放入video窗口
	c = cv.waitKey(50) # 等有键输入(这里指c=Esc键)或者50ms后自动将窗口消除
        if c == 27:
            break
  
  # 视频保存
  # FourCC 就是一个 4 字节码，用来确定视频的编码格式
  # 在Windows上常用的是DIVX。FourCC码以cv.VideoWriter_fourcc('D', 'I','V', 'X')形式传给程序
    fourcc = cv.VideoWriter_fourcc('D', 'I','V', 'X') 以DIVX方式编码
  # 参数说明：输出视频名称，编码格式，播放频率，帧的大小
    out = cv.VideoWriter("output.avi", fourcc, 50.0, (640, 480))

  定义一个循环
  while cap.isOpened(): # 你可以使用 cap.isOpened()，来检查是否成功初始化了
        ret, frame = cap.read()
        if ret is True:
            out.write(frame)

            cv.imshow('frame', frame)

            if cv.waitKey(1) & 0xFF == ord('q'):
                break
        else:
            break

    cap.release()
    out.release()

2.tutorial_numpy

  # 获取图片高宽通道数
  def access_pixels(image):   用image.shape[:]方法
  所谓通道就表示一个图像的颜色 RGB 共同作用表示出图像的颜色

  new_image = image.copy()  # 复制image图片
    for row in range(height):
        for col in range(width):
            for c in range(channels):
                pv = image[row, col, c]
                new_image[row, col, c] = 256 - pv  # 图像反转
  
  #创建一个图像
  def create_image():
  """创建三维数组，0维为B，1维为G，2维为R"""
     img = np.zeros([400, 400, 3], np.uint8) #先用np.xeros()打出一个框 所有像素点三个通道的各个值赋值为0
     img[:, :, 0] = np.ones([400, 400]) * 255 

    “”“
    img[:, :, 0] = np.ones([400, 400]) * 255   #0通道代表B   结果是一个蓝色的图片
    # img[:, :, 1] = np.ones([400, 400]) * 255   #1通道代表G
    # img[:, :, 2] = np.ones([400, 400]) * 255   #2通道代表R
    “”“

    补注：
    1.单通道： 此通道上值为0－255。 （255为白色，0是黑色） 只能表示灰度，不能表示彩色。
    2.三通道：BGR （255，255，255为白色， 0,0,0是黑色 ）  可以表示彩色， 灰度也是彩色的一种。
    3.之所以np.ones函数参数类型是uint8，是因为uint8数的范围为0~255,  那么为0时恰好为黑色，为255时恰好为白色。若函数参数类型为int8，则int8类型数的范围为-128~127，那么-128则为黑色，127为白色

     cv.imshow("new_image", img)
  
  #取反图片
  def inverse(image):  # 取反之后 速度很快 调用的是c的代码
    dst = cv.bitwise_not(image)  #调用这个函数
    cv.imshow("inverse demo", dst)

3.tutorial_colorspace
  """
  色彩空间 对角线表示
  常见的色彩空间 RGB HSV HIS YCrCb YUV
  最常见的色彩转换就是HSV与RGB YUV与RGB  HSV=RGB的转换真的很重要 H:0-180 
  S:0-255 V:0-255
  HSV即Hue(色调),Saturation(饱和度)和Value(亮度)三个channel
  opencv里，COLOR_RGB2GRAY是将三通道RGB对象转换为单通道的灰度对象
  """

  hsv = cv.cvtColor(frame, cv.COLOR_BGR2HSV)  #将BGR转换为HSV模式
  lower_hsv = np.array([])  #设置指定颜色HSV的最低值
  upper_hsv = np.array([])  #设置指定颜色HSV的最高值
  
  mask = cv.inRange(hsv,lower_hsv,upper_hsv)  #利用inrange函数过滤视频中的颜色，实现对特定颜色的追踪
  dst = cv.bitwise_and(frame, frame, mask=mask)  #二值化 灰度显示
  
  #注意
  Opencv的inRange函数：可实现二值化功能

函数原型：inRange(src,lowerb, upperb[, dst]) -> dst         

　　函数的参数意义：第一个参数为原数组，可以为单通道，多通道。第二个参数为下界，第三个参数为上界

例如：mask = cv2.inRange(hsv, lower_blue, upper_blue)      

　　第一个参数：hsv指的是原图（原始图像矩阵）

　　第二个参数：lower_blue指的是图像中低于这个lower_blue的值，图像值变为255

　　第三个参数：upper_blue指的是图像中高于这个upper_blue的值，图像值变为255 （255即代表黑色）

　　而在lower_blue～upper_blue之间的值变成0 (0代表白色)

即：Opencv的inRange函数可提取特定颜色，使特定颜色变为白色，其他颜色变为黑色，这样就实现了二值化功能

  #通道的分离与合并
  b, g, r = cv.split(src)  # 通道分离
  cv.imshow("blue", b)
  cv.imshow("green", g)
  cv.imshow("red", r)

  src = cv.merge([b, g, r])  # 通道合并  
  # 又和之前的图片一模一样咯   注意应该输入一个数组

  src[:, :, 2] = 0  # 对某一个通道赋值 最后一个通道赋值为0 就是把红色给弄没 那个2的意思也就是bgr中的r 给赋值为0也就是给弄没

4.tutorial_algorithm
  #像素运算
  
  #像素的算术运算 必须保证两张图片是一样的大小 shape 和 size必须是一样的
  cv.add cv.subtract cv.divide cv.multiply
  
  #像素的逻辑运算
  cv.bitwise_and(m1,m2) cv.bitwise_or(m1,m2) cv.bitwise_not(m)->255-image
  
  #调节图片的亮度和对比度
  def contrast_brightness_image(img,ratio,b) #ratio表示对比度 b表示亮度
  首先获取到三个通道 h w c 并且 进行初始化 调 np.zeros 方法(第二个参数应该为image.dtype)
  dst = cv.addWeighted(img1, ratio, img2, 1 - ratio, b)  #ratio, 1-ratio为这两张图片的权重
  
  注意：help(cv2.addWeighted)可得到.addWeighted函数的官方解释。

  函数addWeighted的原型：addWeighted(src1, alpha, src2, beta, 
  gamma[, dst[, dtype]]) -> dst

  src1表示需要加权的第一个数组（上述例子就是图像矩阵）

  alpha表示第一个数组的权重

  src2表示第二个数组（和第一个数组必须大小类型相同）

  beta表示第二个数组的权重

  gamma表示一个加到权重总和上的标量值

  即输出后的图片矩阵：dst = src1*alpha + src2*beta + gamma;
  
  #均值和方差
  cv.mean cv.meanStdDev->方差越大说明图图像的差异越大
  
5.tutorial_perspective_transform
"""
ROI（region of interest），感兴趣区域。机器视觉、图像处理中，
从被处理的图像以方框、圆、椭圆、不规则多边形等方式勾勒出需要处理的区域，
称为感兴趣区域，ROI。在Halcon、OpenCV、Matlab等机器视觉软件上常用到各种算子（Operator）和函数来求得感兴趣区域ROI，
并进行图像的下一步处理。

ROI 用numpy获取 长宽高等

"""

"""
泛红填充操作，如何填充一个对象内部的区域
-FLOODFILL_FIXED_RANGE - 改变图像，泛洪填充
-FLOODFILL_MASK_ONLY - 不改变图像，只填充遮罩层本身，忽略新的颜色值参数

floodFill(Mat image, Mat mask, Point seedPoint, Scalar newVal)

floodFill(image, mask, seedPoint, newVal, rect, loDiff, upDiff, flags)

src(seed.x,seed.y)-loDiff <= src(x,y) <= src(seed.x,seed.y)+upDiff

"""

"""
	模糊操作基本原理
	1.基于离散卷积
	2.定义好每个卷积核
	3.不同卷积核得到不同的卷积效果
	4.模糊是卷积的一种表象


	卷积原理
	一维卷积...卷积边缘...


"""
ROI
face = src[200:300, 200:400]    #选择200:300行、200:400列区域作为截取对象 作为ROI

gray = cv.cvtColor(face, cv.COLOR_RGB2GRAY)  #生成的的灰度图是单通道图像 把三通道RGB对象转换为单通道灰度对象

backface = cv.cvtColor(gray, cv.COLOR_GRAY2BGR)  #将单通道图像转换为三通道RGB灰度图，因为只有三通道的backface才可以赋给三通道的src

src[200:300, 200:400] = backface #赋值回去

泛洪填充(彩色图像填充)
mask = np.zeros([h+2, w+2],np.uint8)   #mask必须行和列都加2，且必须为uint8单通道阵列 #为什么要加2可以这么理解：当从0行0列开始泛洪填充扫描时，mask多出来的2可以保证扫描的边界上的像素都会被处理

注意:1.opencv里的mask都是为uin8类型的单通道阵列

泛洪填充(二值图像填充)
cv.floodFill(image, mask, (200,200), (255 , 0, 0), cv.FLOODFILL_MASK_ONLY) #mask不为0的区域不会被填充，mask为0的区域才会被填充

6.tutorial_fliter&vague
均值模糊、中值模糊、用户自定义模糊

均值模糊
    dst = cv.blur(image,(1,15)) # (1，15)是垂直方向模糊 (15,1)是水平方向模糊
中值模糊->对椒盐噪声有很好的效果
    dst = cv.medianBlur(image,5)
用户自定义模糊
    先定义kernel np.ones([5,5],np.float32)/25 自己定义一个kernel 然后/25是为了防止数值溢出
    dst = cv.filter2D(image,-1,kernel)
高斯模糊
    
	"""
	“中间点”取”周围点”的平均值，就会变成1。在数值上，这是一种”平滑化”。在图形上，就相当于产生”模糊”效果，”中间点”失去细节。
	如果使用简单平均，显然不是很合理，因为图像都是连续的，越靠近的点关系越密切，越远离的点关系越疏远。因此，加权平均更合理，距离越近的点权重越大，距离越远的点权重越小。
	正态分布显然是一种可取的权重分配模式。
	计算平均值的时候，我们只需要将”中心点”作为原点，其他点按照其在正态曲线上的位置，分配权重，就可以得到一个加权平均值。

	"""
    轮廓还在 保留图像的主要特征 高斯模糊比均值模糊去噪效果好 h, w, c = image.shape
    for row in range(h):
        for col in range(w):
            s = np.random.normal(0, 20, 3)
            b = image[row, col, 0]   #blue
            g = image[row, col, 1]   #green
            r = image[row, col, 2]   #red
            image[row, col, 0] = clamp(b + s[0])
            image[row, col, 1] = clamp(g + s[1])
            image[row, col, 2] = clamp(r + s[2])

边缘保留滤波EPF(美颜效果)
高斯双边滤波
均值迁移滤波
    
    高斯双边滤波
    dst = cv.bilateralFilter(image,0,100,15)  # 高斯双边 一般把d设置为0 从sigmaColor 和 sigmaSpace 反算出d
    # double sigmaColor: 颜色空间过滤器的sigma值，这个参数的值月大，表明该像素邻域内有越宽广的颜色会被混合
    到一起，产生较大的半相等颜色区域。 （这个参数可以理解为值域核的）
    # double sigmaSpace: 坐标空间中滤波器的sigma值，如果该值较大，则意味着越远的像素将相互影响，从而使更大的
    区域中足够相似的颜色获取相同的颜色。当d>0时，d指定了邻域大小且与sigmaSpace无关，否则d正比于sigmaSpace.    （ 这个参数可以理解为空间域核的）    

    均值迁移
    dst = cv.pyrMeanShiftFiltering(image,10,50) # 均值迁移 如果差值很小的话 就漂移 模糊起来 可能造成过度模糊 类似于油画的效果

9.tutorial_histogram

"""    
图像的直方图是用来表现图像中亮度分布的直方图,给出的是图像中某个亮度或者某个范围亮度下共有几个像素.还不明白?就是统计一幅图某个亮度像素数量.比如对于灰度值12,一幅图里面有2000 个像素其灰度值为12,那么就能够统计12这个亮度的像素为2000个,其他类推。
"""

    画直方图
    plt.hist(image.ravel(), 256, [0, 256])         #numpy的ravel函数功能是将多维数组降为一维数组 hist函数主要是计算直方图 256表示指定bin(箱子的个数)也就是竖条的个数 [0,256]表示箱子的上下限 即横坐标显示的范围 范围之外就被舍弃
    hist = cv.calcHist([image], [i], None, [256], [0, 256])  #计算直方图
 
    直方图的应用
    直方图应用->直方图均衡化(基于灰度图像的)->调整图片的对比度   分为全局和局部的

    直方图均值化的基本思想是对图像中像素个数多的灰度级进行展宽，而对图像中像素个数少的灰度进行压缩，从而扩展像元取值的动态范围，提高了对比度和灰度色调的变化，使图像更加清晰。

    全局直方图均衡化
    gray = cv.cvtColor(image, cv.COLOR_RGB2GRAY)    #opencv的直方图均衡化要基于单通道灰度图像
    dst = cv.equalizeHist(gray)                #自动调整图像对比度，把图像变得更清晰 提高图像质量
    
    局部直方图均值化
    gray = cv.cvtColor(image, cv.COLOR_RGB2GRAY)
    clahe = cv.createCLAHE(5, (8,8))  # 5表示对比度的大小 (8，8)表示每次处理块的大小
    dst = clahe.apply(gray)  # 将这种局部直方图均衡化应用到灰度图




